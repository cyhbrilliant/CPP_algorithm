#递归
将一个大问题分解成逐步递进解决的小问题，小问题可以再继续分解。
如集合全排列，分解成循环固定一个数然后尾数全排列的子问题，这个子问题又可以分解为更小的子问题。


#分治法（解法）
将大问题分解为多个**独立**的路径，每次命中一个路径。
如**二分法**，分解为两边路径，命中一边，然后再分解命中。每次命中一边后与另一边无关——即独立
**棋盘覆盖**，分解为是否有特殊方格和其所在的四角方位，命中一个覆盖后，然后递进。
**快速排序**，每次确定一个位置然后减小问题规模，每次确定一个位置后相当于二分，子问题不会再调用其他子问题数据
因式分解，每次递归解决

#动态规划（最优值）
与分治法思想相同，但子问题不是相互独立的，若用分治法则会重复计算，用一个数组来并保存已经得到的答案就可以避免重复计算。即无论是否用到，只要被计算就保存。
求解最优解可分解为求解递归子问题的最优解
**是对问题约束条件的动态规划而不是对矩阵位置的动态规划，0-1背包问题的思想是当约束重量为0时、1时、2时。。。最大5时，每增加一重量当前的最大价值，如为4时就可以是最大的2+2或是1+2等等，但在计算当前最大时也需要从前n个物品进行递归循环计算，看是否可以装入，然后选取最大的**

**矩阵连乘**利用矩阵乘法结合率，不同的顺序进行乘法所需要的运算量差一个量级
矩阵子链的最优解构成整体的最优解,优化时保存最优数据。
除了保存重复计算的数据外，还需保存解数据，即每次最优括号断开的位置，以便最后可以寻找最优解。
**0-1背包问题**（整个物体只能装一次或者不装即0-1背包问题，若可以拆分装入则为背包问题 适用于贪心算法）设计约束式，分解子问题。分情况 装入 不装入（无容量时） 递归传入
和矩阵相乘一样，都是寻找当前最优值保存 如前n个物品能否装入的最优值。


#贪心算法（最优值）
只有保证在最优解情况下每个子解都为其最优解时才能使用贪心算法，贪心算法不同于动态规划，它不依赖于子结构。动态规划解决的一般是二维的问题，如矩阵连乘，0-1背包问题，保存解结构都是2维矩阵，而贪心算法一般针对一维的问题

贪心算法一般有评判标准，例如在背包问题中，性价比（重量价值比）是评判标准，即贪心是优先选性价比高的物品装入，而非动态规划严格按照子问题的最佳解方案

又如Dijkstra，每次选择当前最小的作为解的一部分。
PRIM kruskal算法也是一样，每次都选择当前最优解而不考虑子问题的解结构。


#回溯法（最优值或等于某值，寻找所有可能值）
二叉树
一种穷举式搜索法，但可以避免不必要的搜索
安装深度优先策略搜索
类似于中序遍历

0-1背包问题可以写成一棵树，如果有3个则为000 010 001 100。。。等 然后1左子树 0右子树 最后进行中序遍历，但有技巧，如当前已经超过背包总重量则不再向下搜索，若当前搜索的价值加上剩余需要搜索的总价值还没超过当前最优值的话，则结束搜索。
回溯按照深度回溯 当深度>树深度时则得到解决方案，否则循环检查剩余的可能情况是否可行然后在可行的情况中递归深度向下调用
如n皇后问题，就是递归建立一颗搜索树的过程。
如子集和问题，类似于0-1背包问题，但却是寻找确定的值是否存在而非最优值

#分支界限法
适用于每次子问题的最优解能导致最后的最优解
也是一种搜索树，采用广度优先搜索或者最大效益搜索。
广度优先即先进先出搜索，按照队列顺序搜索
最大效益搜索即选取队列中效益最大的结点向下搜索
也需要判断限界进行剪枝
单源点最短路径，可以用分支界限法，设置每个结点不可达，然后儿子结点入队列，若到儿子结点的花费小于其当前花费，则加入搜索队列做下一次迭代，若是大于则剪枝。

